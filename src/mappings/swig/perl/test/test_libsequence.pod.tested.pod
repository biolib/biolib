=head1 General I/O

=head2 class Fasta

FASTA Sequence Stream


Fasta(): Generic Constructor

  my $fasta = new libsequence::Fasta();
  
Fasta(name, seq): Constructor for const std::string

  my $fasta = new libsequence::Fasta('dna', 'ATGC');
  
Fasta(fastaObj): Copy constrctor

  my $copy_fasta = new libsequence::Fasta($fasta);
  
GetName(): Return the sequence name
  
  my $name = $fasta->GetName();
  is($name, 'dna');
  
GetSeq(): Return the sequence itself

  my $seq = $fasta->GetSeq();
  is($seq, 'ATGC');

length(): Return the total length of the sequence

  my $len = $fasta->length();
  is($len, 4);
  
UngappedLength(): Return length of sequence, excluding the gap character '-'

  my $fasta1 = new libsequence::Fasta('dna', 'A-C-T');
  my $ungapped_len = $fasta1->UngappedLength();
  is($ungapped_len, 3);
  
IsGapped(): Returns 1 if the sequence contaings the gap character '-', 0 otherwise

  ok($fasta1->IsGapped());
  
substr(beg, len): Returns a substring of the current string, starting at index 'beg' with 'len' characters long.
if len is omitted, returns the substring from index 'beg' to the end of the string.
  
  my $sub_str = $fasta->substr(1, 2);
  is($sub_str, 'TG');
  my $sub_str = $fasta->substr(2);
  is($sub_str, 'GC');
  
c_str(): Returns the C-style string representing the sequence as a cont char *

  is($fasta->c_str(), 'ATGC');
  
to_std_str(): Allows (implict) cast to std::string

  is($fasta->to_std_str(), 'ATGC');
  
Complement():  Complement the Sequence

  $copy_fasta->Complement();
  is($copy_fasta->GetSeq(), 'TACG');
  
Revcom(): Reverse and complement the sequence

  $copy_fasta->Revcom();
  is($copy_fasta->GetSeq(), 'CGTA');

Operator ==: Returns 1 if the sequences contain the same data, 0 otherwise.

  ok(!($fasta == $fasta1));
  
Operator !=: Returns 0 if the sequences contain the same data, 1 otherwise.

  ok($fasta != $fasta1);
  
Operator []: Return the i-th element of the sequence.

  #is($fasta[1], 'T');
  
~Fasta(): Destructor

  $fasta->DESTROY();
  $copy_fasta->DESTROY();
  $fasta1->DESTROY();
 
 
 
 
  
=head1 Divergence Statistics

=head2 class Kimura80

#=for POD::Tested reset

Kimura's 2-parameter distance

Kimura80(seqa, seqb): Constructor, seqa and seqb should be of the same length.

  my $fas1 = new libsequence::Fasta('dna1', 'AGTGCG');
  my $fas2 = new libsequence::Fasta('dna2', 'TGCACT');
  my $kim = new libsequence::Kimura80($fas1, $fas2);

K(): Returns: the distance between the two sequences.

  is($kim->K(), 0);
  
sites(): Returns:the number of sites compared, excluding gaps, missing data, etc.

  is($kim->sites(), 6, "TestSeties");


=head2 class GranthamWeights2

#=for POD::Tested reset

Weights paths by Grantham's distances for codons differing at 2 sites

GranthamWeights2(): Constructor

  my $gran2 = new libsequence::GranthamWeights2();
  
weights(): Returns:a double * of size 2 (1 value for each branch)

  my $weights2 = $gran2->weights();
  ok(defined($weights2));
  print "$weights2\n";
  #my $a = new libsequence::doubleArray(2);
  #print $a;
  #my $y = $a->getitem(0);
  #my $w = libsequence::doubleArray->frompointer($a);



Calculate(): Calculate actually calculates the weights for each branch

  $gran2->Calculate('CGU', 'AGG');
  
~GranthamWeights2(): Destructor

  $gran2->DESTROY;
  
=head2 class GranthamWeights3

Weights paths by Grantham's distances for codons differing at 3 sites.

GranthamWeights3():Constructor

  my $gran3 = new libsequence::GranthamWeights3();
  
weights(): Returns:a double * of size 6 (1 value for each branch)

  my $weights3 = $gran3->weights();
  
Calculate(): Calculate actually calculates the weights for each branch

  $gran3->Calculate('AAA', 'CCC');
  
~GranthamWeights3(): Destructor

 $gran3->DESTROY;
 
=head2 class Unweighted2

weights all pathways equally

  my $unwei2 = new libsequence::Unweighted2();
  
weights(): Returns:a double * of size 2 (1 value for each branch)

  my $unweights2 = $unwei2->weights();
  
Calculate(): Calculate actually calculates the weights for each branch

  $unwei2->Calculate('CGU', 'AGG');
  
~Unweighted2(): Destructor

  $unwei2->DESTROY;
  
=head2 class Unweighted3

weights all pathways equally

  my $unwei3 = new libsequence::Unweighted3();
  
weights(): Returns:a double * of size 6 (1 value for each branch)

  my $unweights3 = $unwei3->weights();
  
Calculate(): Calculate actually calculates the weights for each branch

  $unwei3->Calculate('AAA', 'CCC');
 
~Unweighted3(): Destructor

  $unwei3->DESTROY;
  

=head2 class RedundancyCom95

Calculate redundancy of a genetic code using Comeron's counting scheme

RedundancyCom95(): Constructor

  my $redun = new libsequence::RedundancyCom95();
  
FirstNon(): Returns:number of times the first codon position is non-degenerate

Precondition:codon is of length 3, is all uppercase, and only contains the characters {A,G,C,T}
Exceptions:Sequence::SeqException if precondition is not met

  is($redun->FirstNon('CGA'), 0.5);
  
First2S(): Return number of times the first codon position is synonymous via a transition

  is($redun->First2S('TTT'), 0.0);
  
First2V(): Return number of times the first codon position is synonymous via a transversion

  is($redun->First2V('AGG'), 0.33333333333333331);
  
ThirdNon(): Returns the number of times the third position is non-degenerate

  is($redun->ThirdNon('AGA'), 0.0);
  
ThirdFour(): Returns number of times the third position is fourfold-degenerate

  is($redun->ThirdFour('CGG'), 1.0);
  
Third2S(): Returns number of times the third position is synonymous via a transition

  is($redun->Third2S('AGG'), 1.0);
  
Third2V(): Returns number of times the third position is synonymous via a transversion

  is($redun->Third2V('AGG'), 0.0);
  
L0_vals(): Returns the number of non-degenerate positions in codon

  is($redun->L0_vals('CGG'), 1.6666666666666667);
  
L2S_vals(): Returns the number of transitional silent sites in codon

  is($redun->L2S_vals('AGG'), 1.0);
  
L2V_vals(): Returns the number of transversional silent sites in codon

  is($redun->L2V_vals('AGG'), 0.33333333333333331);
  
L4_vals(): Returns the number of fourfold silent sites in codon

  is($redun->L4_vals('CGG'), 1.0);
  
~RedundancyCom95(): Destructor

  $redun->DESTROY;
  
=head2 class Sites

Calculate length statistics for divergence calculations

Sites(): Constructor

Sites(sitesObj, seq1, seq2, max = 3, code = 0)
Parameters:
sitesObj 	an initialized object of type RedundancyCom95
seq1 	a Seq object
seq2 	a Seq object
max 	max number of substitutions per codon to analyze
code 	see Sequence::GeneticCodes for valid values

Note:
sequences must be of same length, this is checked by assert()
sequence lengths must be multiples of 3, this is checked by assert()

  my $redun = new libsequence::RedundancyCom95();
  my $seq1 = new libsequence::Fasta('n1', 'AGTGCC');
  my $seq2 = new libsequence::Fasta('n2', 'TTGCAG');
  my $sites = new libsequence::Sites($redun, $seq1, $seq2);
  
L0(): Returns alignment length in terms of non-degenerate sites

  is($sites->L0(), 3.5);
  
L2S(): Returns alignment length in terms of transitional-degenerate sites

  is($sites->L2S(), 2.0);
  
L2V(): Returns alignment length in terms of transversional-degenerate sites

  is($sites->L2V(), 0.0);
  
L4(): Returns alignment length in terms of fourfold-degenerate sites

  is($sites->L4(), 0.5);
  
~Sites(): Destructor

  $sites->DESTROY;
  
=head2 class SingleSub

Deal with codons differing at 1 position.

SingleSub(): Constructor

  my $sinsub = new libsequence::SingleSub();
  
operator (): A functor to obtain divergence statistics for Comeron's method for codons that differ at one position. 

  #$sinsub->($redun, 'CAC', 'AAT');
  
P0(): Returns number of transitions at non-degenerate sites in the codon

P2S(): Returns number of transitions at transitional-degenerate sites in the codon

P2V(): Returns number of transitions at transversional-degenerate sites in the codon

P4(): Returns number of transitions at fourfold-degenerate sites in the codon
  
Q0(): Returns number of transversions at non-degenerate sites in the codon

Q2S(): Returns number of transversions at transitional-degenerate sites in the codon
  
Q2V(): Returns number of transversions at transversional-degenerate sites in the codon

Q4(): Returns number of transversions at fourfold-degenerate sites in the codon

~SingleSub(): Destructor

  $sinsub->DESTROY;

=head2 class TwoSubs

=head2 class ThreeSubs

#=head2 class Comeron95

an object to implement Comeron's (1995) method to calculate Ka and Ks
        
Comeron95(seqa, seqb, max = 3, code = UNIVERSAL, _weigths2 = NULL, _weights3 = NULL): 
Constructor, initialize and calculate synonymous and nonsynonymous distances between two sequence objects
Parameters:
seqa 	an object of type or derived from type Sequence::Seq
seqb 	an object of type or derived from type Sequence::Seq
max 	maximum number of substitutions per codon to allow in the analysis
code 	genetic code, see Sequence::GeneticCodes
_weights2 	a weighting scheme for codons differing at 2 positions. If NULL, Sequence::GranthamWeights2 is used
_weights3 	a weighting scheme for codons differing at 3 positions. If NULL, Sequence::GranthamWeights3 is used

Warning:
Note that the pointers to weighting schemes are dumb pointers.
This allows me to check for NULL and then assign a default.
If you use your own classes, make sure they clean up after themselves if they throw exceptions!!!

Exceptions:
if sequence lengths are not equal or if sequence lengths are not multiples of 3
exception will be rasied

  my $seq1 = new libsequence::Fasta('s1', 'GCTACGAGC');
  my $seq2 = new libsequence::Fasta('s2', 'CTTCGGTAG');
  
  my $comeron = new libsequence::Comeron95($seq1, $seq2);
  
ka(): Returns the nonsynonymous distance

  is($comeron->ka(), 0);
  
ks(): Returns the synonymous distance

  is($comeron->ks(), 0.39270813010733246);
  
ratio(): Returns ka/ks

  is($comeron->ratio(), 0);
  
P0(): Returns number of transitions at nondegenerate sites

  is($comeron->P0(), 2.0);
  
P2S(): Returns number of transitions at 2-fold, transitional degenerate sites

  is($comeron->P2S(), 0);
  
P2V(): Returns number of transitions at 2-fold, transversional degenerate sites

  is($comeron->P2V(), 0);
  
P4(): Returns number of transitions at 4-fold degenerate sites

  is($comeron->P4(), 0);
  
Q0(): Returns number of transversion at nondegenerate sites

  is($comeron->Q0(), 3.9044719537318398);
  
Q2S(): Returns number of transversion at 2-fold, transitional degenerate sites

  is($comeron->Q2S(), 0.75747679019931624);
  
Q2V(): Returns number of transversion at 2-fold, transversional sites

  is($comeron->Q2V(), 0.17659143153111975);
  
Q4(): Returns number of transversion at 4-fold degenerate sites

  is($comeron->Q4(), 0.16145982453772428);
  
aa(): Returns corrected nonsynonymous divergence at tranversioal- and non- degenerate sites

  is($comeron->aa(), 0);
  
bs(): Returns corrected nonsynonymous divergence at tranversioal- and non- degenerate sites 

  is($comeron->bs(), 0.18701760636832385);
  
ba(): Returns corrected nonsynonymous divergence at transitional- and non- degenerate sites
 
  is($comeron->ba(), 0);
  
L0(): Returns the number of nondegenerate sites compared

  is($comeron->L0(), 4.8333333333333339);
  
L2S(): Returns the number of twofold, transitional-degenerate sites compared

  is($comeron->L2S(), 0.5);
  
L2V(): Returns the number of twofold, transversional-degenerate sites compared

  is($comeron->L2V(), 0.16666666666666666);
  
L4(): Returns the number of 4-fold degenerate sites compared

  is($comeron->L4(), 2);
  
~Comeron95(): Destructor

  $comeron->DESTROY;
  
  
=head1 Classes and functions to aid in the calculations of the pathways between two condons

This group of classes and functions deals with determining either the counts of silent and replacement 
differences between codons or the intermedate codons that occurs between two different codons
  
=head2 class shortestPath

Calculate shortest path between 2 codons. The length of a path is in terms of the sum
of the Grantham's distances along it's branches.

shortestPath(codon1, codon2, code = UNIVERSAL): Constructor
Parameters:
codon1 	a std::string of length 3
codon2 	a std::string of length 3
code 	which genetic code to use

Precondition:
(codon1.length() == 3 && codon2.length() ==3)
Note:
If either codon1 or codon2 contain characters other than {A,G,C,T}, the pathway type will be assigned shortestPath::AMBIG

  my $path = new libsequence::shortestPath('ATG', 'ACG');

type(): Returns:a value from the enum type shortestPath.pathType representing the type of the shortest path.
Note:enum   pathType { 
                              S, N, SS, SN, 
                              NN, SSS, SSN, SNN, 
                              NNN, NONE, AMBIG 
                            }
                            
  is($path->type(), 1);
  
path_distance(): Returns the total Grantham's distance of the shortest path

  is($path->path_distance(), 81.039692790000004);
  
~shortestPath(): Destructor

  $path->DESTROY;
  

=head1 Function objects defined in the library

=head2 class stateCounter

keep track of state counts at a site in an alignment or along a sequence

stateCounter(): Constructor

  my $states = new libsequence::stateCounter();
  
operator (): function call, add the character in position i,j in an alignment
characters are from {A, T, G, C, N, 0, 1, -}

nStates(): Returns the number of states counted, excluding gaps and missing data

=head1 Miscellany

=head2 sub Translate

=head2 sub TsTv(i, j)

akes two chars, assumed to be nucleotides. The integer returned by this function is a
member of the enumeration type Mutations.

  is(libsequence::TsTv('A', 'G'), 1);
  
Takes two ints, assumed to be integer representations of nucleotides.The way to ensure that
the int represents a nucleotide in a valid way is to use Nucleotides. The return value is
determined by a call to TsTv(int i, int j), where the ints are defined in turn by Nucleotides

  is(libsequence::TsTv(1, 2), 2);
  
=head2 sub Different(seq1, seq2, skip_missing = 1, nucleic_data = 1)

Ask if two strings are different. While this can normally be done by asking if (seq1 != seq2) {},
missing data poses a problem here. If skip-missing == 1, missing data (the 'N' character
for nucleotide data, 'X' for amino acid) are not used to determine if the sequences are different.
If nucleic_acid ==1, nucleotide data are assumed, if nucleic_acid==0, protein data are assumed.
Returns 1 if the seqs are different, 0 otherwise. If the two sequences are of different length, true is returned.

  ok(libsequence::Different('ATGNT', 'ATGT', 1, 1));
  ok(!libsequence::Different('CCN', 'CCT', 1, 1));
  
=head2 sub Gapped()

Returns 1 if the string contains gaps, 0 otherwise
Note: The only gap character checked so far is '-'. Use template version for other gap characters

  ok(libsequence::Gapped('A-G-T'));

=head2 sub NotAGap()  

Returns true if a c is not a gap character, false otherwise.
Note: Currently, only '-' is considered to be a gap character

  ok(!libsequence::NotAGap('-'));

=head2 sub NumDiffs(seq1, seq2, skip_missing = 1, nucleic_acid = 1)

Returns:the number of differences between two std::strings.
Can skip missing data in the same fashion as Comparisons::Different.
If one sequence is shorter than the other, the number of positions compared is the length of the shorter sequence.

  is(libsequence::NumDiffs('AATGC-CT', 'A-T-CCGT'), 4);
  
=head2 class ambiguousNucleotide()

judge if a char is ambigousNuclectide. In other words,
if char(can be lower letter) is not within{A,T,G,C},Return 0 if it is, otherwise 1


=head1 Molecular Population Genetics



  
  
  

























=cut
